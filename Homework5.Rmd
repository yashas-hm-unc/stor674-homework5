---
title: "Homework 5: Version Control, Containerization, and HPC"
author: "STOR 674"
date: "Due: 11/21/2025"
output: 
  html_document:
    toc: true
    toc_float: true
    theme: united
    highlight: tango
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
```

# Overview

This homework will test your knowledge of version control with Git/GitHub, containerization with Docker, and
high-performance computing with Apptainer and Slurm. You will:

1. Answer conceptual questions about Git and GitHub
2. **Create a GitHub repository and version control your Docker image build process (with branching and merging)**
3. Build a Docker image for the Linux environment and push it to Docker Hub
4. Download and run the image on Longleaf using Apptainer and Slurm

**Note:** You may be working on macOS or Windows, but you'll be building Linux containers that will run on Longleaf's
Linux HPC environment.

**Total Points: 100**

**Important:** You will need to submit:

- A PDF/HTML version of this completed Rmd file with your answers
- A link to your GitHub repository
- A link to your Docker Hub image
- Your Slurm job script
- Screenshot/output of your Slurm job completion

---

# Part 1: Git and GitHub Concepts (20 points)

## Question 1.1: Understanding Commits (5 points)

**a)** (3 points) What does a commit do in Git? Explain what information is stored in a commit.

**Answer:**<br>

A commit records a snapshot of staged files and stores metadata like author, timestamp, commit message and reference to
parent commits. It uniquely identifies a commit using an SHA-1 hash.

**b)** (2 points) Why is it important to write descriptive commit messages? Provide an example of a good commit message
and a bad commit message.

**Answer:**<br>

Writing descriptive commit messages is important because it helps you and others understand the purpose of changes,
makes debugging and collaboration easier, and improves project history readability.<br>

Good Commit:<br>
(This is what I follow)<br>
Starts with descriptive function: feat, fix, enhancement, refactor, remove etc.<br>
Ex.<br>
feat: new feature description

Bad Commit:<br>
Ex.<br>
Fixed Bugs

## Question 1.2: Branching in Git (10 points)

**a)** (5 points) Explain how branching works in Git. What happens when you create a new branch? What command would you
use to create a new branch called `feature-analysis` and switch to it?

**Answer:**

Branching allows you to create independent changes by making a pointer to a specific commit. When you create a new
branch, it diverges from the commit you create it from, keeping changes separate from other branches, and
Git only creates a new pointer without copying files. This lets you work on features or fixes without affecting the main
code, and changes in one branch remain isolated until merged.

```bash
git checkout -b feature-analysis
```

**b)** (5 points) Git branching is often described as "super lightweight" compared to other version control systems.
Explain why Git branching is lightweight. (Hint: Think about how Git stores branches and what happens under the hood
when you create a branch.)

**Answer:**

Because a branch in Git is just a pointer to a commit, not a separate copy of files or the entire project. When you
create a new branch, Git simply creates a new reference to the current commit; no file duplication or extra storage is
needed. All branches share the same data objects (commits, trees, blobs), so switching or creating branches is fast and
uses very little disk space.

## Question 1.3: Merging Branches (5 points)

**a)** (3 points) What is the purpose of merging branches? Describe the steps you would take to merge a branch called
`feature-analysis` into the `main` branch.

**Answer:**

The purpose of merging branches is to combine changes from one branch into another, integrating new features, bug fixes,
or updates while preserving history.

```bash
git checkout main
git pull
git merge feature-analysis
```

**b)** (2 points) What is a merge conflict and when does it occur?

**Answer:**

When Git cannot automatically combine changes from two branches because the same part of a file was modified differently
in each branch a merge conflict is raised. It usually happens during a merge or rebase when Git doesn’t know which
version to keep.

---

# Part 2: Docker Image Creation and Deployment with Version Control (50 points)

In this section, you will create a Docker image that can run the `compute_bench.py` script (which you used in Homework
2), which benchmarks CPU/GPU performance using PyTorch. **You will version control the entire process using Git and
GitHub, practicing branching and merging workflows.**

**Important Note on Operating Systems:** You may be working on macOS or Windows, but Docker containers run Linux by
default. You will be building a **Linux-based container** that will run on Longleaf (which is also Linux). Docker
handles the cross-platform compatibility automatically, so your Linux container built on macOS/Windows will work
seamlessly on Longleaf's Linux environment.

## Question 2.0: GitHub Repository Setup (5 points)

Before building your Docker image, you will set up version control for your project.

**a)** (1 points) Create a new GitHub repository called `stor674-homework5` (or similar name). Initialize it with a
README. Provide the GitHub repository URL.

**GitHub Repository URL:**<br>
[Repo Link](https://github.com/yashas-hm-unc/stor674-homework5)

**b)** (2 points) Clone the repository to your local machine, add the provided files (`compute_bench.py`, this
`Homework5.Rmd`), and make your initial commit. What commands did you use?

**Answer:**

```bash
# Commands you used
git init
git branch -M main
git add .
git commit -m "Initial Commit"
git remote add origin https://github.com/yashas-hm-unc/stor674-homework5.git
git push -u origin main
```

**c)** (2 points) Create a new branch called `docker-build` where you will develop your Dockerfile. What command did you
use? Why is it good practice to use a separate branch for development instead of working directly on `main`?

**Answer:**

```bash
# Command to create and switch to branch
git checkout -b docker-build
```

**Explanation:**

Using a separate branch for development is good practice because it keeps the main branch stable and deployable, allows
you to work on new features or fixes without affecting others.

## Question 2.1: Understanding compute_bench.py (5 points)

**a)** (3 points) Read the `compute_bench.py` script. What does this script do? What is its main purpose?

**Answer:**

The script benchmarks tensor computations in PyTorch on CPU and GPU, measuring time to process large arrays, generates a
small sample of random numbers, and saves it to a file.

**b)** (2 points) What Python packages does `compute_bench.py` require?

**Answer:**

- torch (PyTorch)
- time (Standard Lib)

## Question 2.2: Create a Dockerfile (10 points)

Create a Dockerfile that:

- Uses an appropriate **Linux-based** base image with Python 3.9 or later
- Installs the required Python packages (PyTorch with CUDA support for GPU computing)
- Copies `compute_bench.py` into the container
- Sets the default command to run the script

**Important Considerations:**

- **Operating System**: Even if you're on macOS or Windows, Docker will build a Linux container. Use Linux base images (
e.g., `python:3.9-slim` is based on Debian Linux).

- **CUDA Support**: Longleaf has NVIDIA GPUs. To enable GPU support in your container:
  - Option 1: Use official PyTorch image with CUDA: `pytorch/pytorch:2.0.0-cuda11.7-cudnn8-runtime`
  - Option 2: Install PyTorch with CUDA support:
`pip install torch torchvision --index-url https://download.pytorch.org/whl/cu118`
  - Note: The container itself doesn't need NVIDIA drivers (Longleaf provides those), but PyTorch needs to be
CUDA-aware.

- **Testing Locally**: If your computer doesn't have an NVIDIA GPU, the container will still build and run (it will just
use CPU). On Longleaf with GPU nodes, it will automatically detect and use the GPU.

**Instructions:**

1. Make sure you're on the `docker-build` branch
2. Create a file named `Dockerfile` in your repository
3. Write the Dockerfile content below:

```dockerfile
# (Debian Based)
FROM python:3.9-slim

# Set working directory
WORKDIR /scripts

# Install torch dependency
RUN pip install torch torchvision --index-url https://download.pytorch.org/whl/cu118

# Copy the compute_bench.py script into the container
COPY compute_bench.py .

# Default command to run the script
CMD ["python", "compute_bench.py"]
```

**Grading Criteria:**

- Appropriate Linux base image selection (2 points)
- CUDA-enabled PyTorch installation (4 points)
- Proper file copying (2 points)
- Correct CMD or ENTRYPOINT (2 points)

## Question 2.3: Build and Test Docker Image (10 points)

**a)** (3 points) What command did you use to build your Docker image? Include the full command and explain each part.

**Answer:**

For local(Apple M2) arm architecture
```bash
docker build -t hw5 .
```

For longleaf arm architecture
```bash
docker build --platform linux/amd64 -t hw5 .
```

**Explanation:**

- docker build —> Tells Docker to build a new image.
- -t hw5 —> Tags the image for later use.
- . —> The build context (Current Working Directory)

**b)** (4 points) What command did you use to run your Docker image locally to test it? Include the output you received.

**Answer:**

```bash
docker run --rm hw5
```

**Output:**

```
No GPU available, running on CPU only

CPU Computations:
Time for 10,000,000 elements: 0.0979 seconds
Time for 100,000,000 elements: 0.9571 seconds

Small sample of 10 random numbers:
tensor([-0.1326, -1.5500,  1.1859,  1.5597,  0.7008, -0.4011, -1.1648,  0.1153,
        -0.3273, -0.3363])

Saved data to mydata.pt
```

**c)** (3 points) Were there any issues you encountered during the build or test? How did you resolve them?

**Answer:**

No issues, but the `pytorch/pytorch:2.0.0-cuda11.7-cudnn8-runtime` image was greater than 3GB so used the
`python:3.9-slim` image to speed up the build process. I have an Apple M2, the build image architecture was
arm64 but our longleaf runs on amd64, so had to build and push to DockerHub again

## Question 2.4: Version Control Your Docker Build (10 points)

Now that you have a working Dockerfile, let's commit it and merge it into the main branch.

**a)** (3 points) On your `docker-build` branch, add and commit your Dockerfile with a descriptive commit message. What
commands did you use?

**Answer:**

```bash
git add Dockerfile
git commit -m "update: .gitignore, add: Dockerfile"
```

**b)** (4 points) Switch to the `main` branch and merge the `docker-build` branch into it. What commands did you use?
Paste the merge message or output.

**Answer:**

```bash
git checkout main
git merge docker-build -m "merge: changes from docker-build"
```

**Merge Output:**

```
Auto-merging Homework5.Rmd
Merge made by the 'ort' strategy.
 .gitignore    |  3 ++-
 Dockerfile    | 14 ++++++++++++++
 Homework5.Rmd | 78 +++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------
 3 files changed, 65 insertions(+), 30 deletions(-)
 create mode 100644 Dockerfile
```

**c)** (3 points) Push your changes to GitHub. Verify that your repository now contains the Dockerfile on the main
branch. What command did you use to push?

**Answer:**

```bash
git push origin main
```

- [x] **Verification:** Visit your GitHub repository in a web browser and confirm the Dockerfile is visible.

## Question 2.5: Push to Docker Hub (10 points)

**a)** (3 points) Create a Docker Hub account (if you don't have one) and provide your Docker Hub username.

**Docker Hub Username:**

[yashashm](https://hub.docker.com/repositories/yashashm)

**b)** (4 points) Tag your image appropriately and push it to Docker Hub. What commands did you use?

**Answer:**

```bash
docker tag hw5 yashashm/compute-bench-test:latest
docker push yashashm/compute-bench-test:latest
```

**c)** (3 points) Provide the full Docker Hub image URL/name that others can use to pull your image.

**Image URL:**

```
yashashm/compute-bench-test:latest
```

---

# Part 3: Apptainer and Slurm on Longleaf (30 points)

In this section, you will download your Docker image using Apptainer on UNC's Longleaf cluster and submit a job using
Slurm. Remember: your Linux container built on macOS/Windows will run seamlessly on Longleaf's Linux environment.

## Question 3.1: Understanding Apptainer (5 points)

**a)** (3 points) What is Apptainer (formerly Singularity) and why is it used on HPC systems instead of Docker?

**Answer:**

It is a container platform designed for HPC systems. Unlike Docker, it runs containers without root privileges, making
it safe for multi-user clusters. It integrates with HPC schedulers, supports reproducible scientific workflows, and can
even run Docker images securely.

**b)** (2 points) What does "Bring Your Own Environment" (BYOE) mean in the context of HPC and containers?

**Answer:**

It means that users can package all their software, libraries, and dependencies into a container and run it on the
cluster.

## Question 3.2: Convert Docker Image to Apptainer (10 points)

**a)** (5 points) Log into Longleaf and use Apptainer to pull your Docker image from Docker Hub. What command did you
use?

**Answer:**

```bash
modeule load apptainer
apptainer pull compute-bench-test.sif docker://yashashm/compute-bench-test:latest
```

**b)** (3 points) What is the name of the Apptainer image file (.sif) that was created?

**Answer:**

```
compute-bench-test.sif
```

**c)** (2 points) Test your Apptainer image interactively. What command did you use to run it?

**Answer:**

```bash
apptainer shell compute-bench-test.sif
```

## Question 3.3: Create Slurm Job Script (12 points)

Create a Slurm job script that runs your containerized `compute_bench.py` using Apptainer.

**Hint:** If you want to test with GPU support on Longleaf, you'll need to:

- Request a GPU partition (e.g., `#SBATCH -p gpu`)
- Request GPU resources (e.g., `#SBATCH --gres=gpu:1`)
- Your CUDA-enabled PyTorch in the container will automatically use the GPU!

**Instructions:**

1. Create a file named `run_compute_bench.sh` in your GitHub repository
2. Include appropriate Slurm directives (partition, time, memory, etc.)
3. Load necessary modules (if needed)
4. Run the Apptainer container

**Your Slurm Script:**

```bash
#!/bin/bash
#SBATCH --job-name=compute-bench-test       
#SBATCH --output=compute-bench-test.out 
#SBATCH --error=compute-bench-test.err  
#SBATCH --mem=5g
#SBATCH -n 1
#SBATCH -t 01-00:00:00
#SBATCH -p l40-gpu
#SBATCH --qos=gpu_access
#SBATCH --gres=gpu:1

# Load Apptainer module
module load apptainer

# Path to Apptainer image
IMAGE="/nas/longleaf/home/yashashm/hw5/compute-bench-test.sif"

# Run the container
apptainer exec $IMAGE python /nas/longleaf/home/yashashm/hw5/compute_bench.py
```

**Grading Criteria:**

- Appropriate Slurm directives (#SBATCH) (4 points)
- Correct Apptainer run command (6 points)
- Output redirection and job organization (2 points)

## Question 3.4: Submit, Verify, and Version Control (3 points)

**a)** (1 point) What command did you use to submit your job to Slurm?

**Answer:**

```bash
sbatch run_compute_bench.sh
```

**b)** (2 points) Provide the output of your job. Paste the contents of your Slurm output file (e.g.,
`slurm-jobid.out`). Also, add your Slurm script (`run_compute_bench.sh`) to your GitHub repository and push it.

**Job Output:**

```









```

- [x] **GitHub Verification:** Pushed `run_compute_bench.sh` to repository

**c)** (BONUS: +2 points) Include a screenshot showing your job in the Slurm queue or completed job information using
`squeue` or `sacct`. Also show that your job successfully utilized a GPU (if you requested one).

```bash
squeue -u $yashashm
```

**SLURM Queue**
```text
[yashashm@g1416ood06 hw5]$ squeue -u yashashm
             JOBID PARTITION     NAME     USER ST       TIME  NODES NODELIST(REASON)
          22362908   l40-gpu compute- yashashm PD       0:00      1 (Priority)
          22359167 webportal sys-dash yashashm  R      51:33      1 g1416ood06
```
---

# Part 4: Reflection and Best Practices (Optional - Extra Credit: 5 points)

**Question 4.1:** Reflect on the workflow you just completed (Git → Docker → HPC). How does this approach improve
reproducibility in computational research? What are some advantages and potential challenges?

**Answer:**

- Git tracks all code changes, enabling reproducibility and collaboration.
- Docker/Apptainer containers package all dependencies, ensuring code runs the same everywhere.
- Containers can be run on laptops, servers, or HPC clusters without reconfiguration.
- HPC resources can run containerized workloads efficiently, including GPU jobs.
- **Challenges**: Learning curve, storage demands, GPU compatibility, and debugging inside containers can be difficult.

---

# Submission Checklist

Before submitting, make sure you have:

- [x] Completed all questions in Part 1 (Git/GitHub concepts)
- [x] **Created a GitHub repository with all your project files**
- [x] **Practiced branching and merging in your Git workflow**
- [x] Created a Dockerfile with CUDA support for GPU computing
- [x] Built and tested your Docker image locally (Linux container on macOS/Windows)
- [x] Pushed your image to Docker Hub
- [x] Provided your Docker Hub image URL
- [x] Created a Slurm job script
- [x] Successfully ran your job on Longleaf
- [x] **Pushed all files (Dockerfile, Slurm script, completed Rmd) to GitHub**
- [x] Included all output and screenshots
- [x] Compiled this Rmd file to HTML or PDF

**Submission Instructions:**

1. **Ensure your GitHub repository contains:**
 - `Dockerfile`
 - `compute_bench.py`
 - `run_compute_bench.sh` (Slurm script)
 - `Homework5.Rmd` (completed)
 - Evidence of branching/merging in commit history

2. Submit the knitted HTML/PDF file on Canvas
3. **Submit the link to your GitHub repository on Canvas (REQUIRED)**
4. Submit the link to your Docker Hub image on Canvas

---

# Grading Rubric

| Section                                                          | Points  |
|------------------------------------------------------------------|---------|
| Part 1: Git and GitHub Concepts                                  | 20      |
| Part 2: Docker with Version Control (includes branching/merging) | 50      |
| Part 3: Apptainer and Slurm on Longleaf                          | 30      |
| **Total**                                                        | **100** |
| Extra Credit (Part 4: Reflection)                                | +5      |
| Extra Credit (Part 3.4c: GPU screenshot)                         | +2      |
| **Maximum Possible**                                             | **107** |

---

# Resources

- [Git Branching Documentation](https://git-scm.com/book/en/v2/Git-Branching-Branches-in-a-Nutshell)
- [Docker Hub](https://hub.docker.com/)
- [Apptainer Documentation](https://apptainer.org/docs/)
- [Longleaf Documentation](https://help.rc.unc.edu/longleaf-cluster/)
- Course lecture materials on GitHub, Docker, and Apptainer

---

**Good luck!**

